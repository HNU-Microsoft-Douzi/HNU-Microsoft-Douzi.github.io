<!DOCTYPE html>
<html lang="en">
<head>
    <link href="/css/styles_bp.css" rel="stylesheet">
    <link href="/css/style_blog.css" rel="stylesheet">
    <script src="/js/jquery-1.4.4.min.js"></script>
    <script src="/js/main.js"></script>
    <link rel="icon" href="/images/blog.ico" type="image/x-icon" />
    <link rel="shortcut icon" href="/images/blog.ico" type="image/x-icon"/>
    <meta charset="UTF-8">
    <title>All my blogs</title>
    <link media="all" rel="stylesheet" type="text/css" href="/css/rouge.css" />
    <style>
        pre{
            background: rgba(0, 0, 0, 0.95);
        }
    </style>
</head>
<body>
<audio src="/assets/woyuni.mp3" loop="loop" autoplay="autoplay"></audio>
<div class="navigation">
    <div class="main-content">
        <div class="content-photo">
            <img src="/images/logo.png" alt="您要查找的图片不存在啦！">
        </div>
        <h1>Zhang Xiaoyi</h1>
        <hr class="line">
        <p>
            welcome come to my blog,my dear!
        </p>
        <ul id="header-menu">
            <li><a href="http://www.zxyblog.xyz">网站首页</a></li>
            <li><a href="/tags/tags.html" title="技术博文">技术博文</a>
            </li>
            <li><a href="/">个人留言</a></li>
            <li><a href="/">友情链接</a></li>
        </ul>
    </div>
</div>
<div class="blog-content">
    <div class="Wrapper">
        <div class="Header">
            <p class="h0">二叉查找树之路径查询</p>
                <time datetime="2017-12-08 00:00:00 +0800" itemprop="datePublished" class="time_record">2017-12-08</time>
        </div>
        <div class="Content">
            <p class="h1">一、什么是二叉查找树？</p>

<p>二叉查找树(Binary Search Tree)，又称二叉排序树(Binary Sort Tree)，又叫做二叉搜索树。(详细的介绍自己百度，这里不过多阐述。)</p>

<p class="h1"> 二、关于二叉查找树的定义!</p>
<p>二叉查找数是基于二叉树之上的一种数据存储结构，它独特的数据存储方式让数据的查询变得简单。
   对于二叉查找树的每一个节点，都存在一个key值和两个指针域lchild(左孩子),rchild(右孩子)，对于每一个节点而言，它的key值比它的左子树上任意一个节点的key值都大，它的key值比之右子树任意一个节点的key值都要小。
   <img src="#" /></p>

<p class="h1"> 三、对二叉查找树实现的核心思想</p>
<p>我们在这里额外设置一个pparent指针用来指向每个节点的父节点，这样做的好处是便于查找指定节点的双亲节点，也就是说，以下的操作会将树的双亲表示法和孩子表示法联立在一起，关于树的表示法甚至是图的表示法，这里不多做讨论，会在其它的章节中做一个总结。
<br /></p>
<p style="color:blue">详细代码如下：</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="code"><pre>	//构造节点类	
	class Node
	<span class="o">{</span>
	public:
	    Node<span class="o">()</span>:data<span class="o">(</span>0<span class="o">)</span>,pparent<span class="o">(</span>NULL<span class="o">)</span>,lchild<span class="o">(</span>NULL<span class="o">)</span>,rchild<span class="o">(</span>NULL<span class="o">)</span> <span class="o">{}</span><span class="p">;</span>
	    Node<span class="o">(</span>int k<span class="o">)</span>:data<span class="o">(</span>k<span class="o">)</span>,pparent<span class="o">(</span>NULL<span class="o">)</span>,lchild<span class="o">(</span>NULL<span class="o">)</span>,rchild<span class="o">(</span>NULL<span class="o">)</span> <span class="o">{}</span><span class="p">;</span>
	public:
	    int data<span class="p">;</span>
	    Node<span class="k">*</span> pparent<span class="p">;</span>
	    Node<span class="k">*</span> lchild<span class="p">;</span>
	    Node<span class="k">*</span> rchild<span class="p">;</span>
	<span class="o">}</span><span class="p">;</span>//双亲孩子表示法，查找双亲和孩子都非常方便
	//构造二叉查找树
	class BSTree
	<span class="o">{</span>
	public:
	    BSTree<span class="o">()</span><span class="p">;</span>
	    void insert<span class="o">(</span>int k<span class="o">)</span><span class="p">;</span>
	    bool search<span class="o">(</span>int k<span class="o">)</span><span class="p">;</span>//当查找到以后，我要求你返回整个查找树的路径
	    void preOrder<span class="o">()</span><span class="p">;</span>
	    void show_path<span class="o">()</span><span class="p">;</span>
	private:
	    void insert<span class="o">(</span>Node<span class="k">*</span> p, int k<span class="o">)</span><span class="p">;</span>
	    bool search<span class="o">(</span>Node<span class="k">*</span> p, int k<span class="o">)</span><span class="p">;</span>
	    void preOrder<span class="o">(</span>Node <span class="k">*</span>p<span class="o">)</span><span class="p">;</span>
	private:
	    Node<span class="k">*</span> root<span class="p">;</span>
	    stack&lt;int&gt; array<span class="p">;</span>//用来存储树中遍历的路径
	    int size<span class="p">;</span>
	    int search_count<span class="p">;</span>//用来控制查找时树的遍历元素个数
	    bool flag <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="o">}</span><span class="p">;</span>
		bool flag <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="o">}</span><span class="p">;</span></pre></td></tr></tbody></table></code></pre></figure>

<p class="h2"> 插入函数的核心思想</p>
<p>对于查询二叉树而言，它的输入方式以层序的方式进行存入，但是为了满足查询二叉树的特点，我们需要在构建整颗树的过程中对树的状态不断进行调整（这一点的思想在AVL中尤其重要），使其始终满足节点key值大于左子树key值而小于右子树key值，了解了这个以后，我们便可以通过递归地方式对整棵树进行插入操作。</p>
<p style="color:blue">详细代码如下：</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre></td><td class="code"><pre>	void BSTree::insert<span class="o">(</span>int k<span class="o">)</span>
	<span class="o">{</span>
	    insert<span class="o">(</span>root,k<span class="o">)</span><span class="p">;</span>
	<span class="o">}</span>
	
	void BSTree::insert<span class="o">(</span>Node<span class="k">*</span> p,int k<span class="o">)</span>
	<span class="o">{</span>
	    size++<span class="p">;</span>
	    Node <span class="k">*</span>parent <span class="o">=</span> p<span class="p">;</span>
	    <span class="k">if</span><span class="o">(</span>root-&gt;data <span class="o">==</span> NULL<span class="o">)</span>
	    <span class="o">{</span>
	        root-&gt;data <span class="o">=</span> k<span class="p">;</span>
	        <span class="k">return</span><span class="p">;</span>
	    <span class="o">}</span>
	    <span class="k">else</span>
	    <span class="o">{</span>
	        <span class="k">if</span><span class="o">(</span>k &lt; p-&gt;data<span class="o">)</span>
	        <span class="o">{</span>
	            <span class="k">if</span><span class="o">(</span>p-&gt;lchild <span class="o">==</span> NULL<span class="o">)</span>
	            <span class="o">{</span>
	                Node <span class="k">*</span>newNode <span class="o">=</span> new Node<span class="o">(</span>k<span class="o">)</span><span class="p">;</span>
	                newNode-&gt;pparent <span class="o">=</span> p<span class="p">;</span>
	                p-&gt;lchild <span class="o">=</span> newNode<span class="p">;</span>
	            <span class="o">}</span>
	            <span class="k">else
	                </span>insert<span class="o">(</span>p-&gt;lchild, k<span class="o">)</span><span class="p">;</span>
	        <span class="o">}</span>
	        <span class="k">else if</span><span class="o">(</span>k <span class="o">&gt;</span> p-&gt;data<span class="o">)</span>
	        <span class="o">{</span>
	            <span class="k">if</span><span class="o">(</span>p-&gt;rchild <span class="o">==</span> NULL<span class="o">)</span>
	            <span class="o">{</span>
	                Node <span class="k">*</span>newNode <span class="o">=</span> new Node<span class="o">(</span>k<span class="o">)</span><span class="p">;</span>
	                newNode-&gt;pparent <span class="o">=</span> p<span class="p">;</span>
	                p-&gt;rchild <span class="o">=</span> newNode<span class="p">;</span>
	            <span class="o">}</span>
	            <span class="k">else
	                </span>insert<span class="o">(</span>p-&gt;rchild, k<span class="o">)</span><span class="p">;</span>
        <span class="o">}</span>
        <span class="k">else
            return</span><span class="p">;</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<p>这样的话，我们已经完成了树的构建，并且完整的将所有的数据存入树中。</p>

<p class="h1">四、二叉查找树的遍历</p>
<p>树总共有三种遍历方式：前序、中序和后序。
这里我们默认前序进行输出用以检查整个程序在对树的处理上是否出现了问题。
对于二叉查找树的查询，我们构建一个函数并传入要查询的数值k，设置起始点为树的根节点root,从root开始遍历，设置当前节点为pnode，如果pnode-&gt;key小于我们的要查询的k，那么我们递归传入该节点的左子树(pnode-&gt;lchild)，反之，则传入该节点的右子树(pnode-&gt;rchild)，如果在树中找到了k，则返回true(这里我们构造查询函数的返回类型为bool类型),若遍历完整颗树都没有找到，则返回flase。</p>
<p style="color:blue">详细代码如下：</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="code"><pre>	bool BSTree::search<span class="o">(</span>int k<span class="o">)</span>
	<span class="o">{</span>
	    search<span class="o">(</span>root, k<span class="o">)</span><span class="p">;</span>
	<span class="o">}</span>
	
	bool BSTree::search<span class="o">(</span>Node<span class="k">*</span> p, int k<span class="o">)</span>
	<span class="o">{</span>
	    search_count++<span class="p">;</span>
	    <span class="k">if</span><span class="o">(</span>k <span class="o">==</span> p-&gt;data<span class="o">)</span>
	    <span class="o">{</span>
	        flag <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	        array.push<span class="o">(</span>p-&gt;data<span class="o">)</span><span class="p">;</span>
	        cout&lt;&lt;<span class="s2">"您要查找的数存在于树中"</span><span class="p">;</span>
	        <span class="k">return </span><span class="nb">true</span><span class="p">;</span>
	    <span class="o">}</span>
	    <span class="k">else if</span><span class="o">(</span>k &lt; p-&gt;data<span class="o">)</span>
	    <span class="o">{</span>
	        search<span class="o">(</span>p-&gt;lchild,k<span class="o">)</span><span class="p">;</span>
	        <span class="k">if</span><span class="o">(</span>flag<span class="o">)</span> array.push<span class="o">(</span>p-&gt;data<span class="o">)</span><span class="p">;</span>
	    <span class="o">}</span>
	
	    <span class="k">else</span>
	    <span class="o">{</span>
	        search<span class="o">(</span>p-&gt;rchild,k<span class="o">)</span><span class="p">;</span>
	        <span class="k">if</span><span class="o">(</span>flag<span class="o">)</span> array.push<span class="o">(</span>p-&gt;data<span class="o">)</span><span class="p">;</span>
	    <span class="o">}</span>
	    <span class="k">if</span><span class="o">(</span>search_count <span class="o">==</span> size<span class="o">)</span>
	    <span class="o">{</span>
	        cout&lt;&lt;<span class="s2">"您要查找的元素不存在于树中"</span><span class="o">&lt;&lt;</span><span class="no">endl</span><span class="sh">;
	        return false;
	    }
	}</span></pre></td></tr></tbody></table></code></pre></figure>

<p class="h1"> 五、如何实现二叉查找树的路径返回</p>
<p>其实一开始想的时候没有什么思路，但是仔细想想又有种豁然开朗的感觉，下面说说自己的做法。
我在递归查询的过程中，假设我输入的元素在树中可以找到（如果不能找到的话就没有路径返回这一说了），那么我将查找到的元素压入栈中，在递归地过程中，查询完以后，它会向上层返回，这样的话，我只要立一个flag初始化为false,当查找到输入元素时，就让flag为true,然后在每次节点的递归中进行判断，如果说flag为true的话，我就将该节点的key值压入栈中，直到所有操作结束后，一次性返回输出就可以了。</p>
<p style="color:blue">详细代码如下：</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre>		void BSTree::show_path<span class="o">()</span>
		<span class="o">{</span>
		    <span class="k">while</span><span class="o">(!</span>array.empty<span class="o">())</span>
		    <span class="o">{</span>
		        <span class="k">if</span><span class="o">(</span>array.size<span class="o">()</span> <span class="o">!=</span> 1<span class="o">)</span>
		        <span class="o">{</span>
		            cout<span class="o">&lt;&lt;</span><span class="no">array</span><span class="sh">.top()&lt;&lt;"-&gt;";
		        }
		        else
		            cout&lt;&lt;array.top();
		        array.pop();
		    }
	}</span></pre></td></tr></tbody></table></code></pre></figure>

<p style="font-size:25px;font-weight:bold;color:orange">下面是整个程序的完整代码：</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
</pre></td><td class="code"><pre>		<span class="c">#include &lt;stack&gt;</span>
        <span class="c">#include &lt;iostream&gt;</span>
		using namespace std<span class="p">;</span>
		
		class Node
		<span class="o">{</span>
		public:
		    Node<span class="o">()</span>:data<span class="o">(</span>0<span class="o">)</span>,pparent<span class="o">(</span>NULL<span class="o">)</span>,lchild<span class="o">(</span>NULL<span class="o">)</span>,rchild<span class="o">(</span>NULL<span class="o">)</span> <span class="o">{}</span><span class="p">;</span>
		    Node<span class="o">(</span>int k<span class="o">)</span>:data<span class="o">(</span>k<span class="o">)</span>,pparent<span class="o">(</span>NULL<span class="o">)</span>,lchild<span class="o">(</span>NULL<span class="o">)</span>,rchild<span class="o">(</span>NULL<span class="o">)</span> <span class="o">{}</span><span class="p">;</span>
		public:
		    int data<span class="p">;</span>
		    Node<span class="k">*</span> pparent<span class="p">;</span>
		    Node<span class="k">*</span> lchild<span class="p">;</span>
		    Node<span class="k">*</span> rchild<span class="p">;</span>
		<span class="o">}</span><span class="p">;</span>//双亲孩子表示法，查找双亲和孩子都非常方便
		
		class BSTree
		<span class="o">{</span>
		public:
		    BSTree<span class="o">()</span><span class="p">;</span>
		    void insert<span class="o">(</span>int k<span class="o">)</span><span class="p">;</span>
		    bool search<span class="o">(</span>int k<span class="o">)</span><span class="p">;</span>//当查找到以后，我要求你返回整个查找树的路径
		    void preOrder<span class="o">()</span><span class="p">;</span>
		    void show_path<span class="o">()</span><span class="p">;</span>
		private:
		    void insert<span class="o">(</span>Node<span class="k">*</span> p, int k<span class="o">)</span><span class="p">;</span>
		    bool search<span class="o">(</span>Node<span class="k">*</span> p, int k<span class="o">)</span><span class="p">;</span>
		    void preOrder<span class="o">(</span>Node <span class="k">*</span>p<span class="o">)</span><span class="p">;</span>
		private:
		    Node<span class="k">*</span> root<span class="p">;</span>
		    stack&lt;int&gt; array<span class="p">;</span>//用来存储树中遍历的路径
		    int size<span class="p">;</span>
		    int search_count<span class="p">;</span>//用来控制查找时树的遍历元素个数
		    bool flag <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="o">}</span><span class="p">;</span>
		
		BSTree::BSTree<span class="o">()</span>:size<span class="o">(</span>0<span class="o">)</span>,search_count<span class="o">(</span>0<span class="o">)</span>
		<span class="o">{</span>
		    root <span class="o">=</span> new Node<span class="p">;</span>
		<span class="o">}</span>
		
		void BSTree::insert<span class="o">(</span>int k<span class="o">)</span>
		<span class="o">{</span>
		    insert<span class="o">(</span>root,k<span class="o">)</span><span class="p">;</span>
		<span class="o">}</span>
		
		void BSTree::insert<span class="o">(</span>Node<span class="k">*</span> p,int k<span class="o">)</span>
		<span class="o">{</span>
		    size++<span class="p">;</span>
		    Node <span class="k">*</span>parent <span class="o">=</span> p<span class="p">;</span>
		    <span class="k">if</span><span class="o">(</span>root-&gt;data <span class="o">==</span> NULL<span class="o">)</span>
		    <span class="o">{</span>
		        root-&gt;data <span class="o">=</span> k<span class="p">;</span>
		        <span class="k">return</span><span class="p">;</span>
		    <span class="o">}</span>
		    <span class="k">else</span>
		    <span class="o">{</span>
		        <span class="k">if</span><span class="o">(</span>k &lt; p-&gt;data<span class="o">)</span>
		        <span class="o">{</span>
		            <span class="k">if</span><span class="o">(</span>p-&gt;lchild <span class="o">==</span> NULL<span class="o">)</span>
		            <span class="o">{</span>
		                Node <span class="k">*</span>newNode <span class="o">=</span> new Node<span class="o">(</span>k<span class="o">)</span><span class="p">;</span>
		                newNode-&gt;pparent <span class="o">=</span> p<span class="p">;</span>
		                p-&gt;lchild <span class="o">=</span> newNode<span class="p">;</span>
		            <span class="o">}</span>
		            <span class="k">else
		                </span>insert<span class="o">(</span>p-&gt;lchild, k<span class="o">)</span><span class="p">;</span>
		        <span class="o">}</span>
		        <span class="k">else if</span><span class="o">(</span>k <span class="o">&gt;</span> p-&gt;data<span class="o">)</span>
		        <span class="o">{</span>
		            <span class="k">if</span><span class="o">(</span>p-&gt;rchild <span class="o">==</span> NULL<span class="o">)</span>
		            <span class="o">{</span>
		                Node <span class="k">*</span>newNode <span class="o">=</span> new Node<span class="o">(</span>k<span class="o">)</span><span class="p">;</span>
		                newNode-&gt;pparent <span class="o">=</span> p<span class="p">;</span>
		                p-&gt;rchild <span class="o">=</span> newNode<span class="p">;</span>
		            <span class="o">}</span>
		            <span class="k">else
		                </span>insert<span class="o">(</span>p-&gt;rchild, k<span class="o">)</span><span class="p">;</span>
		        <span class="o">}</span>
		        <span class="k">else
		            return</span><span class="p">;</span>
		    <span class="o">}</span>
		<span class="o">}</span>
		
		bool BSTree::search<span class="o">(</span>int k<span class="o">)</span>
		<span class="o">{</span>
		    search<span class="o">(</span>root, k<span class="o">)</span><span class="p">;</span>
		<span class="o">}</span>
		
		bool BSTree::search<span class="o">(</span>Node<span class="k">*</span> p, int k<span class="o">)</span>
		<span class="o">{</span>
		    search_count++<span class="p">;</span>
		    <span class="k">if</span><span class="o">(</span>k <span class="o">==</span> p-&gt;data<span class="o">)</span>
		    <span class="o">{</span>
		        flag <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		        array.push<span class="o">(</span>p-&gt;data<span class="o">)</span><span class="p">;</span>
		        cout&lt;&lt;<span class="s2">"您要查找的数存在于树中"</span><span class="p">;</span>
		        <span class="k">return </span><span class="nb">true</span><span class="p">;</span>
		    <span class="o">}</span>
		    <span class="k">else if</span><span class="o">(</span>k &lt; p-&gt;data<span class="o">)</span>
		    <span class="o">{</span>
		        search<span class="o">(</span>p-&gt;lchild,k<span class="o">)</span><span class="p">;</span>
		        <span class="k">if</span><span class="o">(</span>flag<span class="o">)</span> array.push<span class="o">(</span>p-&gt;data<span class="o">)</span><span class="p">;</span>
		    <span class="o">}</span>
		
		    <span class="k">else</span>
		    <span class="o">{</span>
		        search<span class="o">(</span>p-&gt;rchild,k<span class="o">)</span><span class="p">;</span>
		        <span class="k">if</span><span class="o">(</span>flag<span class="o">)</span> array.push<span class="o">(</span>p-&gt;data<span class="o">)</span><span class="p">;</span>
		    <span class="o">}</span>
		    <span class="k">if</span><span class="o">(</span>search_count <span class="o">==</span> size<span class="o">)</span>
		    <span class="o">{</span>
		        cout&lt;&lt;<span class="s2">"您要查找的元素不存在于树中"</span><span class="p">;</span>
                cout<span class="o">&lt;&lt;</span><span class="no">endl</span><span class="sh">;
		        return false;
		    }
		}
		
		void BSTree::show_path()
		{
		    while(!array.empty())
		    {
		        if(array.size() != 1)
		        {
		            cout&lt;&lt;array.top()&lt;&lt;"-&gt;";
		        }
		        else
		            cout&lt;&lt;array.top();
		        array.pop();
		    }
		}
		
		void BSTree::preOrder()//默认前序输出
		{
		    preOrder(root);
		}
		
		void BSTree::preOrder(Node *p)
		{
		    if(p == NULL) return;
		    else
		    {
		        cout&lt;&lt;p-&gt;data&lt;&lt;" ";
		        preOrder(p-&gt;lchild);
		        preOrder(p-&gt;rchild);
		    }
		}
		
		int main()
		{
		    BSTree bstree;
		    cout&lt;&lt;"情输入您的二叉查找树的元素个数:";
		    int n;
		    cin&gt;&gt;n;
		    cout&lt;&lt;"请输入您的二叉查找树:";
		    for(int i=0; i&lt;n; i++)
		    {
		        int k;
		        cin&gt;&gt;k;
		        bstree.insert(k);
		    }
		    cout&lt;&lt;"您的二叉树前序输出为：";
		    bstree.preOrder();
		    cout&lt;&lt;endl;
		    while(1)
		    {
		        cout&lt;&lt;"请输入您要查找的元素:";
		        int m;
		        cin&gt;&gt;m;
		        if(bstree.search(m))
		            bstree.show_path();
		        cout&lt;&lt;endl;
		    }
		    return 0;
	}</span></pre></td></tr></tbody></table></code></pre></figure>

<p>(blog未曾建设完全，之后会将自己的代码全部托管到github网站上，敬请期待！Bingo~~)</p>

            <br>
            <section>
  <div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more"></a><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a><a href="#" class="bds_tqq" data-cmd="tqq" title="分享到腾讯微博"></a><a href="#" class="bds_renren" data-cmd="renren" title="分享到人人网"></a><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a></div>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"share":{},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["qzone","tsina","tqq","renren","weixin"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>
</section>

            <!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:width="http://www.w3.org/1999/xhtml">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <script type="text/javascript" src="http://apps.bdimg.com/libs/jquery/1.6.4/jquery.min.js"></script>
    <title>打赏</title>
    <style type="text/css">
        .content{width:80%;margin:10px auto;}
                .hide_box{z-index:999;filter:alpha(opacity=50);background:#666;opacity: 0.5;-moz-opacity: 0.5;left:0;top:0;height:99%;width:100%;position:fixed;display:none;}
        .shang_box{width:540px;height:540px;padding:10px;background-color:#fff;border-radius:10px;position:fixed;z-index:1000;left:50%;top:50%;margin-left:-280px;margin-top:-280px;border:1px dotted #dedede;display:none;}
        .shang_box img{border:none;border-width:0;}
        .dashang{display:block;width:100px;margin:5px auto;height:25px;line-height:25px;padding:10px;background-color:#E74851;color:#fff;text-align:center;text-decoration:none;border-radius:10px;font-weight:bold;font-size:16px;transition: all 0.3s;}
        .dashang:hover{opacity:0.8;padding:15px;font-size:18px;}
        .shang_close{float:right;display:inline-block;}
                .shang_logo{display:block;text-align:center;margin:20px auto;}
        .shang_close img{width:25px;}
        .shang_close img:hover{width:35px;transform: translate(0,0);transition:all .2s ease-in 0s;margin-left:-10px;}
        .shang_tit{width: 100%;height: 75px;text-align: center;line-height: 66px;color: #a3a3a3;font-size: 16px;;font-family: 'Microsoft YaHei';margin-top: 7px;margin-right:2px;}
        .shang_tit p{color:#a3a3a3;text-align:center;font-size:16px;}
        .shang_payimg{width:140px;padding:10px;border:6px solid #EA5F00;margin:0 auto;border-radius:3px;height:140px;}
        .shang_payimg img{display:block;text-align:center;width:140px;height:140px; }
        .pay_explain{text-align:center;margin:10px auto;font-size:12px;color:#545454;}
        .radiobox{width: 16px;height: 16px;background: url('/images/da_shang.png');display: block;float: left;margin-top: 5px;margin-right: 14px;}
        .checked .radiobox{background:url('/images/da_shang2.jpg');}
        .shang_payselect{text-align:center;margin:0 auto;margin-top:40px;cursor:pointer;height:60px;width:280px;}
        .shang_payselect .pay_item{display:inline-block;margin-right:10px;float:left;}
        .shang_info{clear:both}
		.shang_info p,.shang_info a{color: #303030;text-align:center;font-size:12px;text-decoration:none;line-height:2em;}
    </style>
</head>

<body>
    <div class="content">
    <p><a href="javascript:void(0)" onclick="dashangToggle()" class="dashang" title="打赏，支持一下">打赏</a></p>
    <div class="hide_box"></div>
    <div class="shang_box">
    	<a class="shang_close" href="javascript:void(0)" onclick="dashangToggle()" title="关闭"><img src="/images/close.jpg" alt="取消" /></a>
        <img class="shang_logo" src="/dsimg/logos.png" alt="张晓翼" />
    	<div class="shang_tit">
    		<p>感谢您的支持，我会继续努力的!</p>
    	</div>
    	<div class="shang_payimg">
    		<img src="/images/da_shang.png" alt="扫码支持" title="扫一扫" />
    	</div>
    		<div class="pay_explain">扫码打赏，你说多少就多少</div>

    	<div class="shang_info">
    		<p>打开<span id="shang_pay_txt">微信</span>扫一扫，即可进行扫码打赏哦</p>
    		<p>分享从这里开始，精彩与您同在</p>
    	</div>
    </div>
    </div>
    <script type="text/javascript">
    $(function(){
    	$(".pay_item").click(function(){
    		$(this).addClass('checked').siblings('.pay_item').removeClass('checked');
    		var dataid=$(this).attr('data-id');
    		$(".shang_payimg img").attr("src","/dsimg/"+dataid+"img.jpg");
    		$("#shang_pay_txt").text(dataid=="alipay"?"支付宝":"微信");
    	});
    });
    function dashangToggle(){
    	$(".hide_box").fadeToggle();
    	$(".shang_box").fadeToggle();
    }
    </script>
</body>
</html>

            <section>
       <ul class="pager">
        
        <li class="previous">
            <a href="/myblog/jekyll/update/2017/11/24/welcome-to-jekyll.html" data-toggle="tooltip" data-placement="top" title="Welcome to Jekyll!">上一篇：  <span>Welcome to Jekyll!</span>
            </a>
        </li>
        
        
        <li class="next">
            <a href="/2017/12/09/bsf%E6%96%87%E4%BB%B6%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F.html" data-toggle="tooltip" data-placement="top" title="bsf文件创建方式">下一篇：  <span>bsf文件创建方式</span>
            </a>
        </li>
        
    </ul>
</section>

            <br>
        </div>
        <div class="FooterPush"></div>
    </div>
</div>
<div align="right" style="color:red">
    <!-- 访问统计 -->
    <script src="/js/traffic_access.js"></script>
</div>
<footer>
    <div id="footer-bottom" style="margin-left:200px"><ul><p>Copyright 2017 design by <a href="/">Zhang Xiaoyi</a></p></ul></div>
</footer>
<script type="text/javascript">

    var a_idx = 0;
    jQuery(document).ready(function($) {
        $("body").click(function(e) {
            var a = new Array("不前方的路有多苦，只要走的方向正确，不管多么崎岖不平，都比站在原地更接近幸福...", "没有光明是不幸的吗？需要光明才是真正的不幸！", "我不知道别离的滋味是这样的凄凉，我不知道说声再见要这么坚强", "我不是天生的王者，但我骨子里流动着不让我低头的血液", "我手里拿着刀，没法保护你。我放下刀，没法拥抱你...", "温柔善良的人总是难以生存，因为这世界既不温柔，也不正确", "错的不是我，是这个世界..." ,"人一生会遇到越2920万人，你爱上我的概率是0.000049，所以你不爱我，我不怪你", "不相信自己的人，连努力的价值都没有", "这世界上所有的不公平都是因为当事人能力的不足导致的", "曾经发生过的事情不可能忘记，只不过是想不起", "只要有你想要保护的东西，那就拔剑好了");
            var $i = $("<span/>").text(a[a_idx]);
            a_idx = (a_idx + 1) % a.length;
            var x = e.pageX,
                    y = e.pageY;
            $i.css({
                "z-index": 999999999999999999999999999999999999999999999999999999999999999999999,
                "top": y - 20,
                "left": x,
                "position": "absolute",
                "font-weight": "bold",
                "color": "#ff6651"
            });
            $("body").append($i);
            $i.animate({
                        "top": y - 180,
                        "opacity": 0
                    },
                    1500,
                    function() {
                        $i.remove();
                    });
        });
    });
</script>
</body>
</html>

