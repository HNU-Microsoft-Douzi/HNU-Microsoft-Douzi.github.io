---
layout: blog-page
data: 2018-01-17
title: "二叉树"
tags: 数据结构
---
<p class="h1">一、二叉树概述</p>
对于二叉树而言，它是树的一种，而它的特点就像其名，在受到树这个数据结构的约束的同时，它的每个节点最多有且只有两个子树，我们通常把这两颗子树依据空间上的排布划分为左子树和右子树。
<img src="/assets/二叉树.jpg">
<br>
（如图所示，就是一棵完整的二叉树）
<br>
<p class="h1">二、二叉树的表示方法</p>
一开始学树的时候，并没有表示方法这个概念，然后有一次吃了大亏才开始重视起来<span style="color:grey">（或许人就是这样的生物吧...）</span>所以在这里要重点提及。

<p class="h2">三种表示方法：</p>
<ul>
   <li>双亲表示法</li>
   <li>孩子表示法</li>
   <li>孩子兄弟表示法</li>
</ul>
<br>
<p class="h3">首先，先来介绍一下双亲表示法:</p>
对一颗完整的树，它的每个节点都有两个域构成，一个数据域，一个指针域，数据域用来存指定的数据，指针域用来指向父节点。
<p style="color:blue">该种方法寻找一个节点的双亲结点比较方便，但是对于寻找一个节点的孩子节点操作实现却不太方便。</p>

<p class="h3">孩子表示法:</p>
每个树节点GNode的域变成了3个，其中有一个数据域和两个指针域，两个指针域分别存左子树和右子树的地址，如果左子树或右子树为空，就让根节点指针域指向NULL。
<p style="color:blue">该方法寻找一个节点的孩子节点操作比较方便，但是寻找一个结点的双亲结点就比较麻烦了。</p>

<p class="h3">孩子兄弟表示法:</p>
每个树节点GNode的域还是3个，其中有一个数据域和两个指针域，两个指针域分别存左子树和兄弟节点的地址，如果左子树或兄弟节点为空，就让根节点指针域指向NULL。
<p style="color:blue">该存储结构其实就是把树转换为一个二叉树的形式去存储，实现比较方便</p>
<p class="h2">三种遍历方法：</p>
<ul>
   <li>前序遍历</li>
   <li>中序遍历</li>
   <li>后序遍历</li>
</ul>

<p>对于三种遍历，我习惯用递归来实现，递归方便操作，也让代码更加简便，下面详细说一下三种遍历的理解：
  
对于前序遍历来说，它是先访问根节点（这里的访问我们通常用显示在屏幕上来表示，也就是说直接用cout输出），访问完根节点以后，开始访问左右子树，先访问其左子树，然后当左子树整个访问完毕后，由递归的特性会返回上一层的右子树，直到整颗树的遍历结束，然后这里需要注意的就是，对于每次递归访问的节点都被当作对应递归层中的根节点来处理。
<p>现对于给定的二叉树给出前序遍历</p>
<img src="/assets/二叉树.jpg"><br>
<p>前序遍历:ABDGHICEJF</p>
<p>现在给出前序实现的伪代码:</p>
{% highlight linenos%}
void BSTree<T>::preOrder(BSNode<T>* p)
{
    if(p != NULL)
    {
        cout<<p->value<<endl;
        preOrder(p->lchild);
        preOrder(p->rchild);
    }
}
{% endhighlight %}

中序遍历的话，和前序遍历有点不同，它是先访问左子树，再输出根节点，然后访问右子树，这涉及到递归操作本身的特性，树中很多操作都要用到递归，虽然学数据结构的时候老师说不要去想递归是怎么进行操作的，但是我认为不去理解递归在编译器中的调用过程就无法详细理解递归操作的本质，会对所学到的东西理解有所偏差，所以对于递归调用的过程不能省略，一定要想，并且要想到明白为止。
<p>现对于给定的二叉树给出中序遍历</p>
<img src="/assets/二叉树.jpg"><br>
<p>中序遍历:GDIHBAEJCF</p>
<p>现在给出中序实现的伪代码:</p>
{% highlight linenos%}
void BSTree<T>::inOrder(BSNode<T>* p)
{
    if(p != NULL)
    {
        inOrder(p->lchild);
        cout<<p->value<<endl;
        inOrder(p->rchild);
    }
}
{% endhighlight %}

后序遍历的话，就是先访问左子树，再访问右子树，最后输出根节点。
<p>现对于给定的二叉树给出后序遍历</p>
<img src="/assets/二叉树.jpg"><br>
<p>后序遍历：GIHDBJEFCA</p>
<p>现在给出后序实现的伪代码:</p>
{% highlight linenos%}
template <class T>
void BSTree<T>::postOrder(BSNode<T>* p)
{
    if(p != NULL)
    {
        postOrder(p->lchild);
        postOrder(p->rchild);
        cout<<p->value<<endl;
    }
}
void BSTree<T>::inOrder(BSNode<T>* p)
{
    if(p != NULL)
    {
        inOrder(p->lchild);
        cout<<p->value<<endl;
        inOrder(p->rchild);
    }
}
{% endhighlight %}
<p style="color:red;font-weight:bold">已知两种遍历方式求原始二叉树：</p>
已知一种遍历方式（前中后序遍历）不能求出原始二叉树。
但是，已知两种遍历方式，我们就可以得到原始二叉树，前提是这两种遍历方式中必须包括中序遍历。
