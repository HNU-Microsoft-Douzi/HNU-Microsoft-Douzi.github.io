---
layout: blog-page
title: "Java 基础语法（持续更新）"
data: 2018-03-19
tags: Java
---
<p class="h1">Java学习中的语法记录:</p>
<p class="h3">Java常量</p>
在 Java 中使用 final 关键字来修饰常量，声明方式和变量类似：
{% highlight java %}
final double PI = 3.1415927;
{% endhighlight %}
<p>当使用常量的时候，前缀 0 表示 8 进制，而前缀 0x 代表 16 进制, 例如：</p>
{% highlight java %}
int decimal = 100;
int octal = 0144;
int hexa =  0x64;
{% endhighlight %}
<br>
<p class="h2">自动类型转换</p>
<p>整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。
<br><br>
转换从低级到高级。</p>
<p style="color:green">低  ------------------------------------>  高</p>
<p style="color:blue">byte,short,char—> int —> long—> float —> double </p>
<br>
<p><b>自动类型转换</b></p>
<p>必须满足转换前的数据类型的位数要低于转换后的数据类型，例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为32，可以自动转换为64位的double类型。</p>
<br>
<p><b>隐含强制类型转换</b></p>
<p>1.整数的默认类型是int</p>
<p>2.浮点型不存在这种情况，因为在定义float类型时必须在数字后面跟上F或者f</p>
<br>

<p class="h3">访问控制和继承</p>
<p>请注意以下方法继承的规则：</p>
<p>父类中声明为 public 的方法在子类中也必须为 public。</p>
<p>父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。</p>
<p>父类中声明为 private 的方法，不能够被继承。</p>
<br>
<p class="h3">final 修饰符</p>
<p><b>final 变量:</b></p>
<p>final 变量能被显式地初始化并且只能初始化一次。被声明为 final 的对象的引用不能指向不同的对象。但是 final 对象里的数据可以被改变。也就是说 final 对象的引用不能改变，但是里面的值可以改变。<br>
final 修饰符通常和 static 修饰符一起使用来创建类常量。</p>
{% highlight java %}
public class Test{
  final int value = 10;
  // 下面是声明常量的实例
  public static final int BOXWIDTH = 6;
  static final String TITLE = "Manager";
 
  public void changeValue(){
     value = 12; //将输出一个错误
  }
}
{% endhighlight %}
<p><b>final 方法</b></p>
<p>类中的 final 方法可以被子类继承，但是不能被子类修改。<br>

声明 final 方法的主要目的是防止该方法的内容被修改。<br>

如下所示，使用 final 修饰符声明方法。</p>
{% highlight java %}
public class Test{
    public final void changeName(){
       // 方法体
    }
}
{% endhighlight %}
<p><b>final类</b></p>
<p>final 类不能被继承，没有类能够继承 final 类的任何特性。</p>
{% highlight java %}
public final class Test {
   // 类体
}
{% endhighlight %}
<p class="h3">synchronized 修饰符</p>
<p>synchronized 关键字声明的方法同一时间只能被一个线程访问。<br>
synchronized 修饰符可以应用于四个访问修饰符。</p>
{% highlight java %}
public synchronized void showDetails(){
.......
}
{% endhighlight %}
<p>volatile 修饰符(涉及到多线程的内存共享，或许会对多线程爬虫的设计有所帮助)</p>
<p>volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。
<br>
而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。<br>
这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。<br>

一个 volatile 对象引用可能是 null。</p>
{% highlight java %}
public class MyRunnable implements Runnable
{
    private volatile boolean active;
    public void run()
    {
        active = true;
        while (active) // 第一行
        {
            // 代码
        }
    }
    public void stop()
    {
        active = false; // 第二行
    }
}
{% endhighlight %}
<br>
<p class="h2">Java Number & Math 类</p>
<p>一般地，当需要使用数字的时候，我们通常使用内置数据类型，如：byte、int、long、double 等。</p>
<p>然而，在实际开发过程中，我们经常会遇到需要使用对象，而不是内置数据类型的情形。为了解决这个问题，Java 语言为每一个内置数据类型提供了对应的包装类。<br>

所有的包装类（Integer、Long、Byte、Double、Float、Short）都是抽象类 Number 的子类。</p>
<img src="/assets/numbers.png"><br>
<p>这种由编译器特别支持的包装称为装箱，所以当内置数据类型被当作对象使用的时候，编译器会把内置类型装箱为包装类。相似的，编译器也可以把一个对象拆箱为内置类型。Number 类属于 java.lang 包。</p>
<br>

<p class="h3">Java Math 类</p>
<p>Java 的 Math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。
<br>
Math 的方法都被定义为 static 形式，通过 Math 类可以在主函数中直接调用。</p>
{% highlight java %}
public class Test {  
    public static void main (String []args)  
    {  
        System.out.println("90 度的正弦值：" + Math.sin(Math.PI/2));  
        System.out.println("0度的余弦值：" + Math.cos(0));  
        System.out.println("60度的正切值：" + Math.tan(Math.PI/3));  
        System.out.println("1的反正切值： " + Math.atan(1));  
        System.out.println("π/2的角度值：" + Math.toDegrees(Math.PI/2));  
        System.out.println(Math.PI);  
    }  
}
{% endhighlight %}
<p>运行结果：</p>
{% highlight java %}
90 度的正弦值：1.0
0度的余弦值：1.0
60度的正切值：1.7320508075688767
1的反正切值： 0.7853981633974483
π/2的角度值：90.0
3.141592653589793
{% endhighlight %}

<p class="h2">JAVA的包装类</p>
<p>  Java语言是一个面向对象的语言，但是Java中的基本数据类型却是不面向对象的，这在实际使用时存在很多的不便，为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，这样八个和基本数据类型对应的类统称为包装类(Wrapper Class)，有些地方也翻译为外覆类或数据类型类。</p>
<img src="/assets/包装类.png"><br>
<p>对于包装类说，这些类的用途主要包含两种：</p>
<p><b> a、作为和基本数据类型对应的类类型存在，方便涉及到对象的操作。</b></p>
<p><b> b、包含每种基本数据类型的相关属性如最大值、最小值等，以及相关的操作方法。</b></p>
<br>
<p><b style="color:red">Integer类内部的常用方法:</b></p>
<p style="color:blue">①、parseInt方法：将数字字符串转换为int数值。</p>
<p style="color:blue">②、toString方法：将int类型转换为对应的String类型。</p>
<p class="h2">Java String 类</p>
<p>length()方法：得到字符串的长度</p>
<p>String类提供了连接两个字符串的方法：</p>
<p>①、string1.concat(string2);</p>
<p>②、用"+"连接符进行连接。</p>
<br>
<p class="h2">Java StringBuffer 和 StringBuilder 类</p>
<p>当对字符串进行修改的时候，需要使用StringBuffer和 StringBuilder 类。</p>
<p>由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。</p>
<p style="color:red"><b>需要注意的是:JAVA中String是一个final的对象，是一个常量！是不可改变的数据，因此才会有StringBuffer和StringBuilder的存在。</b></p>
<p>那么，也许有人会问：下面这个代码是怎么回事？</p>
{% highlight java %}
public class JavaTest {  
    public static void main(String[] args) {  
        String str = "Hello";  
        str = str + " World";  
        System.out.println("str=" + str);  
    }  
}  
{% endhighlight %}
<p>运行结果：</p>
{% highlight java %}
str = Hello World!
{% endhighlight %}
<p style="color:red">那么，造成这样结果的原因是什么？是因为在赋值的时候，str这个变量被存在了栈内存中，而str的值被存在了堆内存中，str实际上是String的一个引用，它本身指向的是一开始的"Hello"所在的堆的内存模块，而通过连接符实质上实现的是在"Hello"的下一个内存模块中存入了数据"World！"，并且把"Hello World!"作为连接完成的数据放入"World!"的下一个内存模块，然后str这个引用就指向了"Hello Wolrd!"这个模块内容，也就是说，改变的是String引用的指向，相当于重新创建了一个对象，它原来的"Hello"还是在堆内存中，并没有被改变。</p>
<br>
<p class="h2">JAVA的数据存储</p>
<p>在使用JAVA的过程中，为了清晰的了解到JAVA语言的本质，特地了解了一下它的数据存储位置，如下：</p>
<p>数据存在内存的时候。JVM对内存管理划分了四个主要区域。</p>
<p>&nbsp&nbsp&nbsp栈区：存放局部变量，对象声明的引用等。</p>
<p>&nbsp&nbsp&nbsp堆区：存放new关键字创建的类（包含成员变量）和数组等。</p>
<p>&nbsp&nbsp&nbsp常量池：存放字符串常量，其他基本数据类型的常量，类的接口的全限定名，属性方法和各种描述符等。</p>
<p>&nbsp&nbsp&nbsp静态域：存放静态变量等。</p>
<br>

<p class="h2">多维数组</p>
<p>声明方式：</p>
{% highlight java %}
String str[][] = new String[3][4];
{% endhighlight %}
<p>对了，这边要提一下实际上JAVA的二维数组不一定要每列元素个数都相等，就比如：</p>
{% highlight java %}
String s[][] = new String[2][];
s[0] = new String[2];
s[1] = new String[3];
s[0][0] = new String("Good");
s[0][1] = new String("Luck");
s[1][0] = new String("to");
s[1][1] = new String("you");
s[1][2] = new String("!");
{% endhighlight %}
<p>其实只要理解了二维数组的定义就可以做到，它的每个元素都是一个数组，所以只要为每一维度分配空间就可以。</p>
<br>

<p class="h3">Java传值还是引用？</p>
<p>要搞清楚这个问题的话，你必须要知道,基本类型和引用类型之间的差别。</p>
<p><b>基本类型的值直接存在内存空间中，而引用类型的内存空间存的是它的地址，引用通常指向一个实际的对象，而这个实际对象一般在另一个内存空间中，并且其中保存着引用的内容。</b></p>
<p>=对于传值而言就是直接改变其内存格中的内容，但对于引用来说，改变的确是引用的指向，举个例子：</p>
{% highlight java %}
int num = 10;
String str = "Hello";

num = 20;
str = "World";
{% endhighlight %}
<p>对于num=20来讲，它直接改变了内存格中的内容，但对于引用来讲，这个World是被新创建的一个位于"Hello"的下一个地址格中的对象，而str的赋值操作则是让str这个引用直接指向了World这个内容，原本的"Hello"是依旧存在的。</p>
<br>
<p class="h3">Arrays 类</p>
<p>java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。</p>
<p>具有以下功能：</p>
<p><b>&nbsp&nbsp&nbsp给数组赋值：通过 fill 方法。</b></p>
<p><b>&nbsp&nbsp&nbsp对数组排序：通过 sort 方法,按升序。</b></p>
<p><b>&nbsp&nbsp&nbsp比较数组：通过 equals 方法比较数组中元素值是否相等。</b></p>
<p><b>&nbsp&nbsp&nbsp查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。</b></p>
<p>要看具体的方法请<a href="http://www.runoob.com/java/java-array.html">click here</a>.</p>
<br>
<p class="h3">Java 休眠(sleep)</p>
<p>sleep()使当前线程进入停滞状态（阻塞当前线程），让出CPU的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会。</p>
<p>你可以让程序休眠一毫秒<span style="color:red">(sleep()的单位是毫秒)</span>的时间或者到您的计算机的寿命长的任意段时间。例如，下面的程序会休眠3秒：</p>
{% highlight java %}
import java.util.*;
  
public class SleepDemo {
   public static void main(String args[]) {
      try { 
         System.out.println(new Date( ) + "\n"); 
         Thread.sleep(1000*3);   // 休眠3秒
         System.out.println(new Date( ) + "\n"); 
      } catch (Exception e) { 
          System.out.println("Got an exception!"); 
      }
   }
}
{% endhighlight %}
<p>这里给出一个测量时间的实例：</p>
{% highlight java %}
import java.util.*;
  
public class DiffDemo {
 
   public static void main(String args[]) {
      try {
         long start = System.currentTimeMillis( );
         System.out.println(new Date( ) + "\n");
         Thread.sleep(5*60*10);
         System.out.println(new Date( ) + "\n");
         long end = System.currentTimeMillis( );
         long diff = end - start;
         System.out.println("Difference is : " + diff);
      } catch (Exception e) {
         System.out.println("Got an exception!");
      }
   }
}

{% endhighlight %}
<p>结果如下：</p>
{% highlight java %}
Tue Mar 20 16:20:57 CST 2018

Tue Mar 20 16:21:00 CST 2018

Difference is : 3056
{% endhighlight %}
<br>
<p class="h3">Calendar类</p>
<p>我们现在已经能够格式化并创建一个日期对象了，但是我们如何才能设置和获取日期数据的特定部分呢，比如说小时，日，或者分钟? 我们又如何在日期的这些部分加上或者减去值呢? 答案是使用Calendar 类。
<br>
Calendar类的功能要比Date类强大很多，而且在实现方式上也比Date类要复杂一些。</p>
<p style="font-size:12px;color:grey">Calender的月份是从0开始的，但日期和年份是从1开始的</p>
<p>具体实现方法<a href="http://www.runoob.com/java/java-date-time.html">click here</a></p>
<br><br>
<p class="h3">命令行参数的使用</p>
<p>终于知道了main函数中的String[] args的作用是什么了：命令行传参的</p>
<b>实例：</b><br>
{% highlight java %}
public class CommandLine {
   public static void main(String args[]){ 
      for(int i=0; i<args.length; i++){
         System.out.println("args[" + i + "]: " + args[i]);
      }
   }
}
{% endhighlight %}
<p>结果：</p>
{% highlight %}
$ javac CommandLine.java 
$ java CommandLine this is a command line 200 -100
args[0]: this
args[1]: is
args[2]: a
args[3]: command
args[4]: line
args[5]: 200
args[6]: -100
{% endhighlight %}
<br><br>
<p class="h3">finalize()方法</p>
<p>等同于C++的析构函数，但是调用方式不一样，finalize()需要被System.gc()主动调用。</p>
<p>一般格式：</p>
{% highlight java %}
protected void finalize()
{
	//这里终结代码
}
{% endhighlight %}
<p>解释：通过修饰符protected，确保finalize()方法不会被该类以外的代码调用。</p>
<p><b>实例：</b></p>
{% highlight java %}
public class FinalizationDemo {  
  public static void main(String[] args) {  
    Cake c1 = new Cake(1);  
    Cake c2 = new Cake(2);  
    Cake c3 = new Cake(3);  
      
    c2 = c3 = null;  
    System.gc(); //调用Java垃圾收集器
  }  
}  
 
class Cake extends Object {  
  private int id;  
  public Cake(int id) {  
    this.id = id;  
    System.out.println("Cake Object " + id + "is created");  
  }  
    
  protected void finalize() throws java.lang.Throwable {  
    super.finalize();  
    System.out.println("Cake Object " + id + "is disposed");  
  }  
}
{% endhighlight %}
<br><br>
<p class="h3">从控制台读取多字符输入</p>
从BufferedReader对象读取一个字符要使用read()方法，它的语法如下：
{% highlight java %}
int read() throws IOEXception
{% endhighlight %}
<p>每次调用read()方法，它从输入流读取一个字符并把该字符作为<span style="color:red">整数</span>返回。当流结束的时候返回-1。该方法抛出IOException。</p>
{% highlight java %}
// 使用 BufferedReader 在控制台读取字符
 
import java.io.*;
 
public class BRRead {
  public static void main(String args[]) throws IOException
  {
    char c;
    // 使用 System.in 创建 BufferedReader 
    BufferedReader br = new BufferedReader(new 
                       InputStreamReader(System.in));
    System.out.println("输入字符, 按下 'q' 键退出。");
    // 读取字符
    do {
       c = (char) br.read();
       System.out.println(c);
    } while(c != 'q');
  }
}
{% endhighlight %}
<p>编译结果如下：</p>
{% highlight java %}
输入字符, 按下 'q' 键退出。
runoob
r
u
n
o
o
b

{% endhighlight %}
<br>
<p class="h3">从控制台读取字符串</p>
<p>从标准输入读取一个字符串需要使用BufferedReader的readLine()方法。</p>
<p>下面的程序读取和显示字符行直到你输入了单词"end"。</p>
{% highlight java %}
// 使用 BufferedReader 在控制台读取字符
import java.io.*;
public class BRReadLines {
  public static void main(String args[]) throws IOException
  {
    // 使用 System.in 创建 BufferedReader 
    BufferedReader br = new BufferedReader(new
                            InputStreamReader(System.in));
    String str;
    System.out.println("Enter lines of text.");
    System.out.println("Enter 'end' to quit.");
    do {
       str = br.readLine();
       System.out.println(str);
    } while(!str.equals("end"));
  }
}
{% endhighlight %}
<p>结果如下：</p>
{% highlight java %}
Enter lines of text.
Enter 'end' to quit.
This is line one
This is line one
This is line two
This is line two
end
end
{% endhighlight %}