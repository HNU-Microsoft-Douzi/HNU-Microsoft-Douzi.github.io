---
title: "MVVM架构模式（连续更新）"
subtitle: "The MVVM pattern"
layout: post
data: 2019-03-17
author: "Zxy"
tags:
    - java
---

> 版权声明：转载请注明博客地址和作者名称


## 前言

架构这一块我一直都没有过一个系统的学习，也没有机会去看关于架构模式的一些书籍，只是当初选择优化项目的时候，采用了MVP的架构模式，才算是对架构模式有了一定的了解，当初看了很多博客，但也因为没有接触过所以理解的很吃力，敲定MVP以后（为什么不用MVVM?因为当时我根本没听过，听过也看不懂MVVM），看了很多关于MVP的资料，去理解它到底是怎样的一个架构模型。

知道MVP相对于MVC解耦更加彻底，尤其是在android开发中更加适应于项目的构建，它用presenter作为桥接来完全解耦view和model,相对MVC而言它不允许model和view进行直接通信，model单拎出来是可以直接进行测试的。

当时感觉很NB，但是让我直接用在项目中我想了很长时间没有好的办法去分离activity的逻辑，因为分不清比如那些监听事件，页面重绘事件到底是处于model层还是view层，我认为谁有谁的理解吧，这也是MVP的一个劣势，它对于这些数据处理并没有一个清晰的分界，所以我把它们当作view的一个部分写在了activity和fragment中，了解过MVVM后我才知道这一切不单单是因为MVP的劣势，另一方面也是因为android的xml功能太弱，只能处理view的显示数据。并且MVP最大的缺点我是在项目构建的过程中发现的，随着整个项目体积越来越大，模块越来越多，MVP产生了大量无法复用的接口类，这进一步增大了文件数目，apk的体积，我开始意识到了MVP只适应于中小型的项目，更近一步，就得使用更强力的MVVM。

这也是我不得不去了解MVVM的原因。

这篇文章我会长期更新，也是我不断深入了解MVVM的一个过程，就像当初学习MVP一样，不可能一下子理解，难点不在于它的抽象概念，那很容易，而是如何完整的将细节构建在项目中，这需要一个时间进行消化。

虽然现在看来MVP很容易，但是我看了几篇关于MVVM的文章，我发现想要在android中集成MVVM并不是一件容易的事情，因为MVVM的数据和视图双向绑定于ViewModel，会实现一个类似通知者模式的架构，Google官方提供了一个专门实现MVVM的库，我照着一个实例写了一个demo，发现xml的写法极其繁琐，并且MVVM的整个架构流程图要庞大的多，想要熟练应用它并不是一件容易的事情。

## 为什么会产生MVVM架构？（MVVM的优势）


- 它提供了关注点的分离。紧密耦合、抗更改、易碎的代码会导致各种长期维护问题，最终导致客户对交付的软件不满意。应用程序逻辑和UI之间的清晰分离将使应用程序更容易测试、维护和发展。它改进了代码重用的机会，并支持开发人员-设计人员工作流。
- 这是XAML平台的一种自然模式。MVVM模式的关键支持因素是Silverlight平台的丰富数据绑定堆栈和依赖项属性。这些组合提供了将UI连接到视图模型的方法。
- 它支持开发人员-设计人员工作流。当UI XAML没有与代码紧密耦合时，设计人员就很容易行使他们需要的自由来进行创新，并创造出一款优秀的产品。
- 它增加了应用程序的可测试性。将UI逻辑移动到一个单独的类，这个类可以独立于UI技术进行实例化，这使得单元测试更加容易。

## 什么是MVVM？

MVVM模式可以被用在所有的xaml平台上，它的目的是为了在用户控制接口和他们的实现逻辑上提供一个清晰可分离的概念。

MVVM模式中有3个组件：view，model和viewmodel。每个部分都有清晰并相互分离的规则。下面的插图展示了三个组件之间的关系。

![https://docs.microsoft.com/en-us/previous-versions/msp-n-p/hh848246(v=pandp.10](https://i.imgur.com/T3Za4bD.png)
（图片来源：[https://docs.microsoft.com/en-us/previous-versions/msp-n-p/hh848246(v=pandp.10](https://docs.microsoft.com/en-us/previous-versions/msp-n-p/hh848246(v=pandp.10 "here")）


组件之间是相互解耦的，因此会有下面的作用：

- 组件可以被调换
- 单个组件内部的实现可以在不影响其他组件的情况下得到改变
- 组件之间可以独立工作
- 可以进行独立的单元测试

为了理解三个组件的职责，重要的是理解组件之间是怎样影响其他组件的。在一个较高的级别上，view是知道view model的，但是model并不知道view model的存在，并且view model不知道view。

view model的存在让view和逻辑类相隔离并且允许逻辑模块可以独立于view存在，这正是可以实现模块单元测试的基础。

### View(就是android中的xml文件和activity/fragment)

视图负责定义用户在屏幕上看到的结构、布局和外观。理想情况下，视图完全是用XAML定义的，只有有限的代码，不包含业务逻辑。

在Windows Phone应用程序中，视图通常是应用程序中的一个页面。此外，视图可以是父视图的子组件，也可以是ItemsControl中对象的DataTemplate。

视图可以有自己的视图模型，也可以继承父视图模型。视图通过绑定或调用视图模型上的方法从其视图模型获取数据。在运行时，当UI控件响应引发更改通知事件的视图模型属性时，视图将发生更改。

有几个选项用于在视图模型上执行代码以响应视图上的交互，例如单击按钮或选择项。如果控件是命令源，则可以将控件的命令属性数据绑定到视图模型上的ICommand属性。当调用控件的命令时，将执行视图模型中的代码。除了命令之外，还可以将行为附加到视图中的对象，并侦听要调用的命令或要引发的事件。作为响应，该行为可以调用视图模型上的ICommand或视图模型上的方法。

### Model

MVVM中的模型是应用程序域模型的实现，其中包括数据模型以及业务和验证逻辑。
模型对象的示例包括存储库、业务对象、数据传输对象(dto)、普通旧CLR对象(POCOs)以及生成的实体和代理对象。

### View Model

view model扮演着viewh model之间的中介，并且它的职责就是出列view逻辑，view model和model交互通过调用model类的方法。然后view model可以以view可以轻松使用的方式来提供逻辑数据。view model从model中检索数据然后将数据转变为view可以利用的形式，当然，view model也可以重定义数据的格式让它给view处理的更容易。

为了让view model参与view和model的双向数据绑定，它的属性必须引发PropertyChanged事件。

(未完待续，之后会将自己的demo地址附上，并完善MVVM的模式内容)