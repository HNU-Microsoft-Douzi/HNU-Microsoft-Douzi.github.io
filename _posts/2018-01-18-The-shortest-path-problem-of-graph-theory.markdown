---
layout: post
title: "图论最短路径问题"
subtitle: "Talk something about how to solve the shortest path problem of graph theory"
data: 2018-01-18
header-img: "https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=272000304,1992252522&fm=27&gp=0.jpg"
author: "Zxy"
tags:
    - C++
    - 数据结构
---
## 一、最短路径问题概述
用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。

## 二、实现最短路径问题的几种算法
首先，先来看实现最短路径问题有哪些算法？

* Dijkstra算法：单源最短路径
* Floyed算法:多源最短路径
* Prim算法:最小支撑树
* Kruskal算法:最小支撑树

### Dijkstra算法图解:
<img src="/assets/Dijkstra.jpg">

`Dijkstra`算法通常用来求单源的最短路径，但是应用`Dijkstra`算法有一个限制，就是图中不能存在负权边。

**算法思想**：设`G=(V,E)`是一个带权有向图，把图中顶点集合V分成两组，第一组为已求出最短路径的顶点集合（用S表示，初始时S中只有一个源点，以后每求得一条最短路径 , 就将加入到集合S中，直到全部顶点都加入到S中，算法就结束了），第二组为其余未确定最短路径的顶点集合（用U表示），按最短路径长度的递增次序依次把第二组的顶点加入S中。在加入的过程中，总保持从源点v到S中各顶点的最短路径长度不大于从源点v到U中任何顶点的最短路径长度。此外，每个顶点对应一个距离，S中的顶点的距离就是从v到此顶点的最短路径长度，U中的顶点的距离，是从v到此顶点只包括S中的顶点为中间顶点的当前最短路径长度。

### Prim算法图解：
<img src="/assets/Prim.jpg">

Prim算法的核心思想就是取两个数组，u和v，u用来存在树中的节点，而v用来存没有在树中的节点及其特定信息，特定信息就是该节点到u中任意节点的最小边权值，然后从v中开始找到最小的代价边，将它加入源节点所在的树中，并将其加入u数组中，并在v数组中把该节点删除，与此同时更新v中的每个节点到u中任意节点的最小边权值，重复上面的操作，直到v中没有元素存在。

### Kruskal算法图解：
<img src="/assets/Kruskal算法图解.png">

`Kruskal`算法的思想就是将所有的边按照权值的大小从小到大进行排序，存入一个数组当中，开始的时候将每个节点当作一个单独的树，然后依次把边由小到大取出并进行判断，如果取出一条边的邻接点位于不同的树上，那么就可以把它们合并在同一棵树上，如果位于相同的树上，则舍弃该边，直到所有边全部遍历完成。