---
layout: blog-page
title: "图论最短路径问题"
data: 2018-01-18
tag: 数据结构
---
<p class="h1">一、最短路径问题概述</p>
用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。
<br>
<p class="h1">二、实现最短路径问题的几种算法</p>

首先，先来看实现最短路径问题有哪些算法？<br>
<ul style="margin-left:15px">
<li>Dijkstra算法：单源最短路径</li>
<li>Floyed算法:多源最短路径</li>
<li>Prim算法:最小支撑树</li>
<li>Kruskal算法:最小支撑树</li>
</ul>

<p class="h3">Dijkstra算法图解:</h3>
<p><img src="/assets/Dijkstra.jpg"></p>
<p>Dijkstra算法通常用来求单源的最短路径，但是应用Dijkstra算法有一个限制，就是图中不能存在负权边。<br>
算法思想：设G=(V,E)是一个带权有向图，把图中顶点集合V分成两组，第一组为已求出最短路径的顶点集合（用S表示，初始时S中只有一个源点，以后每求得一条最短路径 , 就将加入到集合S中，直到全部顶点都加入到S中，算法就结束了），第二组为其余未确定最短路径的顶点集合（用U表示），按最短路径长度的递增次序依次把第二组的顶点加入S中。在加入的过程中，总保持从源点v到S中各顶点的最短路径长度不大于从源点v到U中任何顶点的最短路径长度。此外，每个顶点对应一个距离，S中的顶点的距离就是从v到此顶点的最短路径长度，U中的顶点的距离，是从v到此顶点只包括S中的顶点为中间顶点的当前最短路径长度。</p>

<p class="h3">Prim算法图解：</h3>
<p><img src="/assets/Prim.jpg"></p>
<p>Prim算法的核心思想就是取两个数组，u和v，u用来存在树中的节点，而v用来存没有在树中的节点及其特定信息，特定信息就是该节点到u中任意节点的最小边权值，然后从v中开始找到最小的代价边，将它加入源节点所在的树中，并将其加入u数组中，并在v数组中把该节点删除，与此同时更新v中的每个节点到u中任意节点的最小边权值，重复上面的操作，直到v中没有元素存在。</p>
<br>

<p class="h3">Kruskal算法图解：</h3>
<p><img src="/assets/Kruskal算法图解.png"></p>
<p>Kruskal算法的思想就是将所有的边按照权值的大小从小到大进行排序，存入一个数组当中，开始的时候将每个节点当作一个单独的树，然后依次把边由小到大取出并进行判断，如果取出一条边的邻接点位于不同的树上，那么就可以把它们合并在同一棵树上，如果位于相同的树上，则舍弃该边，直到所有边全部遍历完成。</p>